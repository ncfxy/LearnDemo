# 高性能 MySQL

## 1. MySQL 架构与历史

- 逻辑架构
  - 客户端、连接器、授权认证、安全
  - 查询解析、分析、优化执行、缓存
  - 存储引擎
- 并发控制
  - 读锁/共享锁、写锁/排他锁
  - 表锁、行级锁
  - 事务：原子性(Atomicity)、一致性(Consistency)、隔离性(Isolation)、持久性(Durability)
  - 隔离级别：未提交读、提交读、可重复读(默认)、串行化(脏读、不可重复读、幻读)
  - 死锁：（互斥、保持、不剥夺、循环等待），超时识别、InnoDB将最少排他锁的事务回滚
  - 事务日志：回滚日志（原子性）、重做日志（持久性）
  - MySQL事务：存储引擎实现，事务不可跨引擎，InnoDB支持事务，MyISAM不支持
  - 多版本并发控制(MVCC)：应用在提交读和可重复读
    - InnoDB-Select: 读版本号小于当前，删除版本号大于当前
    - Insert/Delete: 更新当前版本号
    - Update: 插入新记录、为原记录加上删除版本号
- MySQL存储引擎
  - show table status like `tableName` \G
  - InnoDB
    - 使用MVCC支持并发
    - 基于聚簇索引建立
    - 支持事务
  - MyISAM
    - 全文索引、压缩、空间函数(GIS)
    - 不支持事务、不支持崩溃恢复
    - 可以表加锁
    - 支持全文索引
    - 压缩表：不能修改，节省空间、性能高
  - 选择：
    - 日志型应用：Insert/Select多，MyISAM
    - 订单处理：支持事务InnoDB
    - 读多写少：MyISAM(崩溃风险)或者InnoDB
    - CD-ROM应用：使用MyISAM压缩表节省空间

## 5. 创建高性能索引

- 索引对查询性能优化最有效的手段
- 索引的类型
  - B+树
    - 值按顺序存储
    - MyISAM使用前缀压缩，InnoDB引用被索引的行
    - 适用全值匹配、范围查找、键前缀查找
  - 哈希索引
    - Memory引擎默认使用哈希索引
    - InnoDB默认的自适应hash索引
    - 常用(CRC32或者MD5/SHA1取前缀)
    - 自定义哈希索引：增加一个列，查询时手动where
  - 空间数据索引(R-Tree): MyISAM、地理数据存储、空间函数(GIS)
  - 全文索引
- 索引的优缺点
  - 减少扫描数据量
  - 避免排序和临时表
  - 随机I/O变为顺序I/O
  - 适用情况：查找记录带来的优化 > 维护的额外工作
- 高性能的索引策略
  - 独立的列：不要使用表达式或者函数
  - 前缀索引：数据太长时使用, 尽量提高选择性
  - 多列索引：避免自动索引合并
  - 索引列顺序：选择性高的放前边(选择完剩余数量少的)
- 聚簇索引
  - InnoDB数据行放在索引的叶子中
  - 一个表中只能有一个聚簇索引
  - 优点：相关数据在一起、访问更快、覆盖索引可以直接使用叶子主键
  - 缺点：插入速度依赖插入顺序、更新索引代价高、页面分裂?、二级索引会变大(引用了主键)
  - 数据分布：
    - MyISAM:数据顺序保存，索引建立B+树
    - InnoDB：数据直接保存在聚簇索引叶子，二级索引保存主键值
  - InnoDB中使用一个自增长主键来实现顺序插入
- 覆盖索引
  - 一个索引包含查询需要字段(不需要回表继续查询其他数据)
- 使用索引扫描来做排序
  - 索引的排序的左前缀覆盖了查询的排序
- 压缩索引
  - MyISAM节省空间以创建更多索引
- 冗余和重复索引
  - 主键以自动创建索引
  - 多列索引的前缀再创建属于冗余
  - 加入索引会减慢Insert、Update、Delete操作
  - 冗余、未使用索引：工具识别、删除
- 索引和锁
  - 索引能减少InnoDB的访问行数
- 索引案例学习
  - 。。。。。。
- 使用索引的总结
  - 单行访问很慢
  - 顺序访问范围数据很快，避免排序操作
  - 索引覆盖查询很快

## 6. 查询性能优化

- 为什么查询速度会慢
  - 优化子任务：减少次数、让子任务更快
- 慢查询基础：优化数据访问
  - 通常是访问了太多不必要的数据
    - 查询不需要的记录：没有加LIMIT
    - 多表关联是返回全部列
    - 总是去除全部列：使用select *
    - 重复查询相同数据：没有使用缓存
  - 判断MySQL是否再扫描额外记录
    - 相应时间：服务时间 + 排队时间
    - 扫描的行数/返回的行数： 理想状态相等
    - 扫面行数&访问类型：（索引>覆盖索引>全表UsingWhere)
- 查询重构方式
  - 复杂查询vs多个简单查询：衡量性能与网络开销
  - 切分查询：减少锁住的数据量、减少事务系统资源的占用
  - 分解关联查询为多个单查询：
    - 缓存效率更高、减少锁竞争、后期的数据库拆分
    - 借助ID提升查询效率、应用层哈希关联
- 查询执行的基础
  - 执行流程：查询缓存、SQL解析、预处理、优化器生成执行计划、调用API
  - C/S通信协议：半双工、不要执行太长的查询、结果再本地缓存
  - 查询状态：Sleep、Query、Locked、Analyzing and statistics、Copying to tmp table、The thread is、Sending data
  - MySQL查询缓存
  - 查询优化处理
    - 语法解析和预处理：生成解析树来验证语法及权限
    - 查询优化器：找到最优的执行计划
      - 基于统计信息来评估成本，统计信息由查询引擎提供
      - 与实际会有偏差
      - 不考虑并发、不考虑不受控的操作成本
      - 静态优化(编译时转化)、动态优化(跟上下文有关)
      - 优化类型：重新定义关联表顺序、外连接转化成内连接、等价变换、优化count+Min+Max等函数、预估并转化常数表达式、覆盖索引扫描、子查询优化、提前终止查询、等值传播、列表IN的比较
    - 执行关联查询: 先把查询结果放到临时表，再UNION
    - 执行计划：生成一棵指令树、左侧深度优先
    - 关联查询优化器：优化多个表关联的顺序
    - 排序优化：
      - 使用索引排序不需要再进行排序操作
      - 使用快速排序
    - 查询执行引擎
    - 返回结果给客户端




