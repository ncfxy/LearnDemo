# 大话设计模式

## 1. 简单工厂模式

- 面向对象
  - 可维护、可复用、可扩展、灵活性好
  - 封装、继承、多态
  - 简单工厂模式：继承 + 通过工厂实例化不同的对象
  - UML类图
    - (正常、斜体、`<<interface>>`)类名 | (+-#)字段和属性 | (+-#)方法
    - 继承、实现、组合、聚合、关联、依赖

## 2. 商场促销-策略模式(Strategy)

- 拥有不同的打折策略
- 策略模式：它定义了算法家族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化，不会影响到使用算法的客户
  - 一个Context类，维护一个strategy的引用，来执行具体的算法
  - 这些算法在完成相同的工作，只是实现不同, 可以用相同的方式调用
  - 每个算法可以分别单元测试
  - 避免了堆在一起使用if语句

## 3. 单一职责原则

- 定义：就一个类而言，应该仅有一个引起它变化的原因
- 如果一个类承担的职责过多，就等于把这些职责耦合在一起，一个职责的变化可能会削弱或抑制这个类完成其他职责的能力
- 这种耦合会导致脆弱的设计，当变化发生时，设计会遭受到意想不到的破坏
- 软件设计真正要做的许多内容，就是发现职责并把那些职责相互分离

## 4. 开发-封闭原则

- 定义：软件实体（类、模块、函数等）应该可以被扩展，但是不可修改
- 在最初编写代码的时，假设变化不会发生。当变化发生时，就创建抽象来隔离以后发生的同类变化
- 面对需求，对程序的改动是通过增加新代码进行，而不是更改现有的代码

## 5. 依赖倒转原则 & 里氏代换原则

- 依赖倒转原则
  - 高层模块不应该依赖低层模块，两个都应该依赖抽象
  - 抽象不应该依赖细节，细节应该依赖抽象
  - 针对接口编程，不要针对实现编程
- 里氏代换原则(LSP)
  - 子类型必须能够替换掉它们的父类型
  - 把父类都替换成它的子类，程序的行为没有变化

## 6. 装饰模式(Decorator)

- 动态地给一个对象添加一些额外的职责(就增加功能来说，装饰模式比生成子类更为灵活)
- 装饰对象的实现和如何使用这个对象分离
- 为已有功能添加更多功能的方式
- 只在特殊场景下需要修饰，有效地把类的核心职责和装饰功能区分开

## 7. 代理模式(Proxy)

- 为其他对象提供一种代理以控制对这个对象的访问
- 代理类实现同样的接口，代理类拥有对代理对象的控制权
- 主要用途：
  - 远程代理：为一个对象在不同的地址空间提供局部代表，以隐藏这个对象存在于不同地址空间的事实
  - 虚拟代理：通过它存放实例化需要很长时间的真是对象（浏览器图片加载）
  - 安全代理：控制真是对象的访问权限
  - 智能指引：调用真实对象时，代理处理另外一些事情(AOP)
