# 前端面试问题准备

## CSS

1. CSS 选择器解析顺序
    为什么要从右往左解析
2. 为什么要避免使用!important;
3. Flex布局
4. 介绍一下标准的CSS的盒子模型？与低版本IE的盒子模型有什么不同的？
    标准盒子模型：宽度=内容的宽度（content）+ border + padding + margin
    低版本IE盒子模型：宽度=内容宽度（content+border+padding）+ margin

## JavaScript

1. 防抖(debounce)和节流(throttle)
    防抖：搜索、滚动
    节流：降低触发频率
2. 是否了解React
3. Vue
    动态绑定的原理
4. 考察var的变量提升
    What will the console log in this example?

    var foo = 1
    var foobar = function() {
        console.log(foo)
        var foo = 2
    }
    foobar()
5. 事件的捕获和冒泡
6. 事件委托
    3 What is event delegation and why is it useful? Can you show an example of how to use it?

    Event delegation is a technique of delegating events to a single common ancestor. Due to event bubbling, events "bubble" up the DOM tree by executing any handlers progressively on each ancestor element up to the root that may be listening to it.

    DOM events provide useful information about the element that initiated the event via Event.target. This allows the parent element to handle behavior as though the target element was listening to the event, rather than all children of the parent or the parent itself.

    This provides two main benefits:

    It increases performance and reduces memory consumption by only needing to register a single event listener to handle potentially thousands of elements.
    If elements are dynamically added to the parent, there is no need to register new event listeners for them.
7. JavaScript 对比
    const a = [1, 2, 3]
    const b = [1, 2, 3]
    const c = "1,2,3"

    console.log(a == c) // true
    console.log(a == b) // false

    JavaScript performs automatic type conversion
    Objects are compared by reference
    Primitives are compared by value
8. JavaScript原型链的理解
9. Call 和 Apply的区别
    - 使用apply实现一个bind函数
    Function.prototype.bind2 = function (context) {
        if (typeof this !== "function") {
        throw new Error("Function.prototype.bind - what is trying to be bound is not callable");
        }
        var self = this;
        var args = Array.prototype.slice.call(arguments, 1);

        var fNOP = function () {};

        var fBound = function () {
            var bindArgs = Array.prototype.slice.call(arguments);
            return self.apply(this instanceof fNOP ? this : context, args.concat(bindArgs));
        }

        fNOP.prototype = this.prototype;
        fBound.prototype = new fNOP();
        return fBound;
    }
10. 主任务队列和微任务队列
11. 编程

- 实现一个红绿灯函数
- 使用CSS或者Canvas实现可视化的效果
- 使用setTimeout为什么会卡顿，使用requestAnimationFrame更准确

```javascript
function trafficLight(redSecond, greenSecond, yellowSecond);
function red() {console.log('red');}
function green() {console.log('green');}
function yellow() {console.log('yellow');}
```

## Vue

1. 什么是虚拟DOM
2. Vue动态绑定的实现原理

## React

1. React中key的作用
2. shouldComponentUpdate 是做什么的
3. 为什么虚拟 dom 会提高性能
4. React diff的原理
5. 类组件(Class component)和函数式组件(Functional component)之间有何不同
6. 是否了解Hooks
7. 是否了解HOC(高阶组件)

## ES6

- 箭头函数：
  - 自动绑定this
  - 不可当做构造函数
  - 不可使用arguments

## 项目相关

1. 项目中使用了哪些技术
2. 使用怎么样的打包构建流程
3. 项目缓存策略
4. 项目划分
5. 都使用过哪些方法来优化前端性能

## 浏览器

1. 缓存
2. 页面渲染流程
3. XSS攻击
    What is a cross-site scripting attack (XSS) and how do you prevent it?

    XSS refers to client-side code injection where the attacker injects malicious scripts into a legitimate website or web application. This is often achieved when the application does not validate user input and freely injects dynamic HTML content.

    For example, a comment system will be at risk if it does not validate or escape user input. If the comment contains unescaped HTML, the comment can inject a <script> tag into the website that other users will execute against their knowledge.

    The malicious script has access to cookies which are often used to store session tokens. If an attacker can obtain a user’s session cookie, they can impersonate the user.
    The script can arbitrarily manipulate the DOM of the page the script is executing in, allowing the attacker to insert pieces of content that appear to be a real part of the website.
    The script can use AJAX to send HTTP requests with arbitrary content to arbitrary destinations.

    On the client, using textContent instead of innerHTML prevents the browser from running the string through the HTML parser which would execute scripts in it.
    On the server, escaping HTML tags will prevent the browser from parsing the user input as actual HTML and therefore won't execute the script.
4. CSRF攻击
5. DDos攻击
